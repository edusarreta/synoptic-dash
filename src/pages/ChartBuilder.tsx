import { useState, useEffect } from "react";
import { AppLayout } from "@/components/layout/AppLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Checkbox } from "@/components/ui/checkbox";
import { ChartRenderer } from "@/components/charts/ChartRenderer";
import { TableSelector } from "@/components/charts/TableSelector";
import { DataConfigurationPanel, DataConfiguration } from "@/components/charts/DataConfigurationPanel";
import { FieldSelector, SelectedField } from "@/components/charts/FieldSelector";
import { useToast } from "@/hooks/use-toast";
import { usePermissions } from "@/hooks/usePermissions";
import { useDatabase } from "@/hooks/useDatabase";
import { useAuth } from "@/hooks/useAuth";
import { supabase } from "@/integrations/supabase/client";
import { BarChart3, LineChart, PieChart, Hash, Table, Play, Save, Wand2, Code, Filter } from "lucide-react";

const SAMPLE_DATA = [
  { month: 'Jan', sales: 4000, profit: 2400, customers: 240 },
  { month: 'Feb', sales: 3000, profit: 1398, customers: 210 },
  { month: 'Mar', sales: 2000, profit: 9800, customers: 290 },
  { month: 'Apr', sales: 2780, profit: 3908, customers: 300 },
  { month: 'May', sales: 1890, profit: 4800, customers: 181 },
  { month: 'Jun', sales: 2390, profit: 3800, customers: 250 },
];

interface ChartBuilderProps {
  editChartId?: string | null;
}

export default function ChartBuilder({ editChartId }: ChartBuilderProps = {}) {
  const { permissions } = usePermissions();
  const { toast } = useToast();
  const { user } = useAuth();
  const { connections, tables, loading, loadConnections, loadTables, executeQuery } = useDatabase();
  
  // Chart configuration
  const [chartType, setChartType] = useState<'table' | 'bar' | 'line' | 'pie' | 'kpi' | 'area' | 'composed' | 'scatter' | 'radial' | 'treemap' | 'funnel' | 'advanced-table'>('bar');
  const [chartTitle, setChartTitle] = useState('');
  const [chartDescription, setChartDescription] = useState('');
  const [chartId, setChartId] = useState<string | null>(null);
  
  // Data source configuration
  const [selectedConnection, setSelectedConnection] = useState('');
  const [selectedTables, setSelectedTables] = useState<string[]>([]);
  const [selectedFields, setSelectedFields] = useState<SelectedField[]>([]);
  
  // Filter configuration - NOVA FUNCIONALIDADE LOOKER STYLE
  const [filterableColumns, setFilterableColumns] = useState<string[]>([]);
  
  // Query and preview
  const [sqlQuery, setSqlQuery] = useState('');
  const [autoGeneratedQuery, setAutoGeneratedQuery] = useState('');
  const [data, setData] = useState(SAMPLE_DATA);
  const [isExecuting, setIsExecuting] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [currentTab, setCurrentTab] = useState('visual');
  const [isLoading, setIsLoading] = useState(false);
  
  // Data configuration
  const [dataConfiguration, setDataConfiguration] = useState<DataConfiguration>({
    fields: [],
    categoryFields: [],
    statusFields: []
  });

  // Load connections and chart data on mount
  useEffect(() => {
    loadConnections();
    if (editChartId) {
      loadChartForEditing(editChartId);
    }
  }, [editChartId]);

  // Load tables when connection changes
  useEffect(() => {
    console.log('Connection changed to:', selectedConnection);
    if (selectedConnection) {
      loadTables(selectedConnection).then(() => {
        setSelectedTables([]);
        setSelectedFields([]);
        setSqlQuery('');
        setAutoGeneratedQuery('');
      });
    } else {
      // Clear everything when no connection is selected
      setSelectedTables([]);
      setSelectedFields([]);
      setSqlQuery('');
      setAutoGeneratedQuery('');
    }
  }, [selectedConnection, loadTables]);

  // Auto-generate query when fields change
  useEffect(() => {
    if (selectedFields.length > 0 && selectedTables.length > 0) {
      generateAutoQuery();
    }
  }, [selectedFields, selectedTables]);

  const generateAutoQuery = () => {
    const dimensions = selectedFields.filter(f => f.role === 'dimension');
    const metrics = selectedFields.filter(f => f.role === 'metric');
    
    if (dimensions.length === 0 && metrics.length === 0) return;

    let query = 'SELECT\n';
    
    // Add dimensions
    if (dimensions.length > 0) {
      query += dimensions.map(d => `  ${d.tableName}.${d.columnName}`).join(',\n');
    }
    
    // Add metrics
    if (metrics.length > 0) {
      if (dimensions.length > 0) query += ',\n';
      query += metrics.map(m => {
        const agg = m.aggregation || 'COUNT';
        return `  ${agg}(${m.tableName}.${m.columnName}) as ${m.columnName}_${agg.toLowerCase()}`;
      }).join(',\n');
    }
    
    // Add FROM clause
    query += `\nFROM ${selectedTables[0]}`;
    
    // Add JOINs if multiple tables
    if (selectedTables.length > 1) {
      for (let i = 1; i < selectedTables.length; i++) {
        query += `\n  -- TODO: Add appropriate JOIN condition for ${selectedTables[i]}`;
        query += `\n  -- JOIN ${selectedTables[i]} ON condition`;
      }
    }
    
    // Add GROUP BY if we have both dimensions and metrics
    if (dimensions.length > 0 && metrics.length > 0) {
      query += '\nGROUP BY\n';
      query += dimensions.map((d, index) => `  ${index + 1}`).join(',\n');
    }
    
    query += '\nLIMIT 100;';
    
    setAutoGeneratedQuery(query);
    if (currentTab === 'visual') {
      setSqlQuery(query);
    }
  };

  // Load chart data for editing
  const loadChartForEditing = async (chartId: string) => {
    setIsLoading(true);
    try {
      const { data: chart, error } = await supabase
        .from('saved_charts')
        .select(`
          *,
          data_connections!inner(
            id,
            name,
            database_name,
            connection_type
          )
        `)
        .eq('id', chartId)
        .single();

      if (error) {
        throw error;
      }

      if (chart) {
        setChartId(chart.id);
        setChartTitle(chart.name);
        setChartDescription(chart.description || '');
        setChartType(chart.chart_type as any);
        setSqlQuery(chart.sql_query || '');
        setAutoGeneratedQuery(chart.sql_query || ''); // Set both for consistency
        setSelectedConnection(chart.data_connection_id);
        
        // Set filterable columns from chart config
        if (chart.chart_config && typeof chart.chart_config === 'object' && 'filterableColumns' in chart.chart_config) {
          const config = chart.chart_config as any;
          if (Array.isArray(config.filterableColumns)) {
            setFilterableColumns(config.filterableColumns);
          }
        }

        // Execute the query to get current data
        try {
          const result = await executeQuery(chart.data_connection_id, chart.sql_query);
          setData(result.data);
        } catch (queryError) {
          console.error('Error executing chart query:', queryError);
        }

        toast({
          title: "Chart Loaded",
          description: `Chart "${chart.name}" loaded successfully for editing`,
        });
      }
    } catch (error) {
      console.error('Error loading chart:', error);
      toast({
        title: "Error",
        description: "Failed to load chart for editing",
        variant: "destructive"
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleConnectionChange = (connectionId: string) => {
    console.log('游댃 Changing connection to:', connectionId);
    console.log('游댃 Available connections:', connections.map(c => ({ id: c.id, name: c.name, database: c.database_name })));
    
    // Force clear everything immediately
    setSelectedTables([]);
    setSelectedFields([]);
    setSqlQuery('');
    setAutoGeneratedQuery('');
    setSelectedConnection(connectionId);
  };

  const handleTableToggle = (tableName: string) => {
    setSelectedTables(prev => {
      if (prev.includes(tableName)) {
        return prev.filter(t => t !== tableName);
      } else {
        return [...prev, tableName];
      }
    });
  };

  const handleFieldToggle = (field: SelectedField) => {
    setSelectedFields(prev => {
      const existing = prev.find(f => 
        f.tableName === field.tableName && f.columnName === field.columnName
      );
      
      if (existing) {
        return prev.filter(f => 
          !(f.tableName === field.tableName && f.columnName === field.columnName)
        );
      } else {
        return [...prev, field];
      }
    });
  };

  const handleFieldRoleChange = (field: SelectedField, role: 'dimension' | 'metric') => {
    setSelectedFields(prev => 
      prev.map(f => 
        f.tableName === field.tableName && f.columnName === field.columnName
          ? { ...f, role }
          : f
      )
    );
  };

  const handleRefreshTables = () => {
    if (selectedConnection) {
      loadTables(selectedConnection);
    }
  };

  const handleExecuteQuery = async () => {
    if (!sqlQuery.trim()) {
      toast({
        title: "Error",
        description: "Please enter a SQL query",
        variant: "destructive"
      });
      return;
    }

    if (!selectedConnection) {
      toast({
        title: "Error",
        description: "Please select a data connection",
        variant: "destructive"
      });
      return;
    }

    setIsExecuting(true);
    
    try {
      const result = await executeQuery(selectedConnection, sqlQuery);
      setData(result.data);
      toast({
        title: "Query Executed",
        description: `Retrieved ${result.rowCount} rows`,
      });
    } catch (error) {
      // Error is already handled in useDatabase hook
    } finally {
      setIsExecuting(false);
    }
  };

  // Filterable columns management
  const handleFilterableColumnToggle = (columnName: string) => {
    setFilterableColumns(prev => {
      if (prev.includes(columnName)) {
        return prev.filter(col => col !== columnName);
      } else {
        return [...prev, columnName];
      }
    });
  };

  const handleSaveChart = async () => {
    if (!chartTitle.trim()) {
      toast({
        title: "Error",
        description: "Please enter a chart title",
        variant: "destructive"
      });
      return;
    }

    if (!selectedConnection) {
      toast({
        title: "Error",
        description: "Please select a data connection",
        variant: "destructive"
      });
      return;
    }

    // For editing mode, get the query from the existing chart if no new query is provided
    let queryToSave = sqlQuery.trim() || autoGeneratedQuery.trim();
    
    // Debug logging
    console.log("Save Chart Debug:", {
      chartId,
      sqlQuery: sqlQuery.length,
      autoGeneratedQuery: autoGeneratedQuery.length,
      queryToSave: queryToSave.length,
      isEditing: !!chartId,
      actualSqlQuery: sqlQuery,
      actualAutoQuery: autoGeneratedQuery
    });
    
    // If we're editing and no new query is provided, fetch the original query from database
    if (chartId && !queryToSave) {
      try {
        const { data: existingChart, error } = await supabase
          .from('saved_charts')
          .select('sql_query')
          .eq('id', chartId)
          .single();
        
        if (existingChart && !error) {
          queryToSave = existingChart.sql_query;
          console.log("Using existing chart query:", queryToSave);
        }
      } catch (error) {
        console.error('Error fetching existing chart query:', error);
      }
    }
    
    if (!queryToSave) {
      toast({
        title: "Error",
        description: "Please provide a SQL query or generate one using the visual builder",
        variant: "destructive"
      });
      return;
    }

    try {
      setIsSaving(true);

      // Get user's account_id first
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('account_id')
        .eq('id', user.id)
        .single();

      if (profileError) {
        throw profileError;
      }

      // Create chart configuration (JSON compatible)
      const chartConfig = {
        type: chartType,
        title: chartTitle,
        description: chartDescription,
        xAxis: selectedFields.find(f => f.role === 'dimension')?.columnName || availableColumns[0] || '',
        yAxis: selectedFields.filter(f => f.role === 'metric').map(f => f.columnName) || availableColumns.slice(1) || [],
        filterableColumns: filterableColumns // NOVA FEATURE: Colunas dispon칤veis para filtro
      };

      let savedChart, error;
      
      if (chartId) {
        // Update existing chart
        const result = await supabase
          .from('saved_charts')
          .update({
            name: chartTitle,
            description: chartDescription,
            chart_type: chartType,
            sql_query: queryToSave,
            chart_config: chartConfig,
            updated_at: new Date().toISOString()
          })
          .eq('id', chartId)
          .select()
          .single();
        
        savedChart = result.data;
        error = result.error;
      } else {
        // Create new chart
        const result = await supabase
          .from('saved_charts')
          .insert({
          account_id: profile.account_id,
          data_connection_id: selectedConnection,
          name: chartTitle,
          description: chartDescription,
          chart_type: chartType,
          sql_query: queryToSave,
          chart_config: chartConfig,
            created_by: user.id
          })
          .select()
          .single();
        
        savedChart = result.data;
        error = result.error;
      }

      if (error) {
        throw error;
      }

      toast({
        title: chartId ? "Chart Updated" : "Chart Saved",
        description: chartId ? "Your chart has been updated successfully" : "Your chart has been saved successfully",
      });

      if (!chartId) {
        // Reset form only for new charts
        setChartTitle('');
        setChartDescription('');
        setSqlQuery('');
        setFilterableColumns([]);
        setData(SAMPLE_DATA);
      } else {
        // Update chartId after first save
        setChartId(savedChart?.id || chartId);
      }
      
    } catch (error) {
      console.error('Error saving chart:', error);
      toast({
        title: "Error",
        description: chartId ? "Failed to update chart. Please try again." : "Failed to save chart. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsSaving(false);
    }
  };

  const availableColumns = data.length > 0 ? Object.keys(data[0]) : [];

  if (!permissions?.canCreateCharts) {
    return (
      <AppLayout>
        <div className="p-6">
          <Card className="max-w-md mx-auto">
            <CardHeader className="text-center">
              <BarChart3 className="w-12 h-12 mx-auto mb-4 text-muted-foreground" />
              <CardTitle>Access Denied</CardTitle>
              <CardDescription>
                You don't have permission to create charts.
              </CardDescription>
            </CardHeader>
          </Card>
        </div>
      </AppLayout>
    );
  }

  if (isLoading) {
    return (
      <AppLayout>
        <div className="p-6 space-y-6">
          <div className="flex items-center justify-center min-h-96">
            <div className="text-center">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
              <p>Carregando gr치fico...</p>
            </div>
          </div>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <div className="p-6 space-y-6">
        {/* Header */}
        <div>
          <h1 className="text-3xl font-bold text-foreground">
            {editChartId ? 'Editar Gr치fico' : 'Chart Builder'}
          </h1>
          <p className="text-muted-foreground mt-1">
            {editChartId ? 'Modifique seu gr치fico e configure filtros personalizados' : 'Create interactive charts and visualizations from your data - Looker Studio style'}
          </p>
        </div>

        <div className="grid grid-cols-1 xl:grid-cols-4 gap-6">
          {/* Left Panel - Data Source & Fields */}
          <div className="xl:col-span-1 space-y-6">
            {/* Data Source Selection */}
            <TableSelector
              key={selectedConnection} // Force re-render when connection changes
              connections={connections}
              tables={tables}
              selectedConnection={selectedConnection}
              selectedTables={selectedTables}
              loading={loading}
              onConnectionChange={handleConnectionChange}
              onTableToggle={handleTableToggle}
              onRefreshTables={handleRefreshTables}
            />

            {/* Field Selection */}
            {selectedTables.length > 0 && (
              <FieldSelector
                tables={tables}
                selectedTables={selectedTables}
                selectedFields={selectedFields}
                onFieldToggle={handleFieldToggle}
                onFieldRoleChange={handleFieldRoleChange}
              />
            )}
          </div>

          {/* Center Panel - Configuration */}
          <div className="xl:col-span-2 space-y-6">
            {/* Chart Configuration */}
            <Card className="glass-card border-0 shadow-card">
              <CardHeader>
                <CardTitle>Chart Configuration</CardTitle>
                <CardDescription>
                  Configure your chart settings and preview
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="title">Chart Title</Label>
                    <Input
                      id="title"
                      value={chartTitle}
                      onChange={(e) => setChartTitle(e.target.value)}
                      placeholder="Enter chart title"
                    />
                  </div>
                  <div>
                    <Label htmlFor="type">Chart Type</Label>
                    <Select value={chartType} onValueChange={(value: any) => setChartType(value)}>
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent className="max-h-80">
                        <SelectItem value="advanced-table">
                          <div className="flex items-center gap-2">
                            <Table className="w-4 h-4" />
                            Advanced Table
                          </div>
                        </SelectItem>
                        <SelectItem value="table">
                          <div className="flex items-center gap-2">
                            <Table className="w-4 h-4" />
                            Simple Table
                          </div>
                        </SelectItem>
                        <SelectItem value="bar">
                          <div className="flex items-center gap-2">
                            <BarChart3 className="w-4 h-4" />
                            Bar Chart
                          </div>
                        </SelectItem>
                        <SelectItem value="line">
                          <div className="flex items-center gap-2">
                            <LineChart className="w-4 h-4" />
                            Line Chart
                          </div>
                        </SelectItem>
                        <SelectItem value="area">
                          <div className="flex items-center gap-2">
                            <LineChart className="w-4 h-4" />
                            Area Chart
                          </div>
                        </SelectItem>
                        <SelectItem value="pie">
                          <div className="flex items-center gap-2">
                            <PieChart className="w-4 h-4" />
                            Pie Chart
                          </div>
                        </SelectItem>
                        <SelectItem value="radial">
                          <div className="flex items-center gap-2">
                            <PieChart className="w-4 h-4" />
                            Radial Chart
                          </div>
                        </SelectItem>
                        <SelectItem value="scatter">
                          <div className="flex items-center gap-2">
                            <Hash className="w-4 h-4" />
                            Scatter Plot
                          </div>
                        </SelectItem>
                        <SelectItem value="kpi">
                          <div className="flex items-center gap-2">
                            <Hash className="w-4 h-4" />
                            KPI Card
                          </div>
                        </SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div>
                  <Label htmlFor="description">Description (Optional)</Label>
                  <Input
                    id="description"
                    value={chartDescription}
                    onChange={(e) => setChartDescription(e.target.value)}
                    placeholder="Enter chart description"
                  />
                </div>
              </CardContent>
            </Card>

            {/* Query Builder */}
            <Card className="glass-card border-0 shadow-card">
              <CardHeader>
                <CardTitle>Query Builder</CardTitle>
                <CardDescription>
                  Build your query visually or write SQL directly
                </CardDescription>
              </CardHeader>
              <CardContent>
                <Tabs value={currentTab} onValueChange={setCurrentTab}>
                  <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="visual" className="flex items-center gap-2">
                      <Wand2 className="w-4 h-4" />
                      Visual Builder
                    </TabsTrigger>
                    <TabsTrigger value="sql" className="flex items-center gap-2">
                      <Code className="w-4 h-4" />
                      SQL Editor
                    </TabsTrigger>
                  </TabsList>
                  
                  <TabsContent value="visual" className="space-y-4">
                    {autoGeneratedQuery ? (
                      <div className="space-y-2">
                        <Label>Auto-generated Query:</Label>
                        <Textarea
                          value={autoGeneratedQuery}
                          readOnly
                          className="min-h-32 font-mono text-sm"
                        />
                        <p className="text-xs text-muted-foreground">
                          This query is automatically generated based on your field selections.
                          Switch to SQL Editor to customize it.
                        </p>
                      </div>
                    ) : (
                      <div className="text-center py-8 text-muted-foreground">
                        <Wand2 className="w-8 h-8 mx-auto mb-2 opacity-50" />
                        <p className="text-sm">Select fields to auto-generate a query</p>
                      </div>
                    )}
                  </TabsContent>
                  
                  <TabsContent value="sql" className="space-y-4">
                    <div>
                      <Label>Custom SQL Query:</Label>
                      <Textarea
                        value={sqlQuery}
                        onChange={(e) => setSqlQuery(e.target.value)}
                        placeholder="SELECT * FROM your_table WHERE condition..."
                        className="min-h-32 font-mono"
                      />
                    </div>
                  </TabsContent>
                </Tabs>

                <div className="flex gap-2 mt-4">
                  <Button 
                    onClick={handleExecuteQuery} 
                    disabled={isExecuting || !selectedConnection || !sqlQuery.trim()}
                    className="flex-1"
                  >
                    <Play className="w-4 h-4 mr-2" />
                    {isExecuting ? "Executing..." : "Execute Query"}
                  </Button>
                  <Button onClick={handleSaveChart} variant="outline" disabled={isSaving}>
                    <Save className="w-4 h-4 mr-2" />
                    {isSaving ? "Saving..." : "Save Chart"}
                  </Button>
                </div>
                
                {/* Debug Info - Temporary */}
                {editChartId && (
                  <div className="mt-4 p-3 bg-muted/20 rounded-md text-xs">
                    <h4 className="font-semibold mb-2">Debug Info:</h4>
                    <div className="space-y-1">
                      <div>Chart ID: {chartId || 'None'}</div>
                      <div>SQL Query Length: {sqlQuery.length}</div>
                      <div>Auto Query Length: {autoGeneratedQuery.length}</div>
                      <div>Connection: {selectedConnection || 'None'}</div>
                      <div>Title: {chartTitle || 'Empty'}</div>
                      <div>Can Save: {!!(chartTitle.trim() && selectedConnection && (sqlQuery.trim() || autoGeneratedQuery.trim())) ? 'Yes' : 'No'}</div>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Data Configuration Panel */}
            <DataConfigurationPanel
              tables={tables}
              selectedTables={selectedTables}
              data={data}
              configuration={dataConfiguration}
              onConfigurationChange={setDataConfiguration}
              className="glass-card border-0 shadow-card"
            />
            
            {/* Filter Configuration */}
            {availableColumns.length > 0 && (
              <Card className="glass-card border-0 shadow-card">
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Filter className="w-5 h-5" />
                    Configura칞칚o de Filtros
                  </CardTitle>
                  <CardDescription>
                    Selecione quais colunas podem ser usadas como filtros no dashboard (estilo Looker Studio)
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-3">
                    {availableColumns.map((column) => (
                      <div key={column} className="flex items-center space-x-3">
                        <Checkbox
                          id={`filter-${column}`}
                          checked={filterableColumns.includes(column)}
                          onCheckedChange={() => handleFilterableColumnToggle(column)}
                        />
                        <Label 
                          htmlFor={`filter-${column}`} 
                          className="text-sm font-medium cursor-pointer flex-1"
                        >
                          {column}
                        </Label>
                        <span className="text-xs text-muted-foreground">
                          {filterableColumns.includes(column) ? 'Filtr치vel' : 'N칚o filtr치vel'}
                        </span>
                      </div>
                    ))}
                  </div>
                  {filterableColumns.length > 0 && (
                    <div className="mt-4 p-3 bg-muted/50 rounded-md">
                      <p className="text-xs text-muted-foreground">
                        <strong>{filterableColumns.length}</strong> coluna(s) selecionada(s) para filtros din칙micos
                      </p>
                    </div>
                  )}
                </CardContent>
              </Card>
            )}
          </div>

          {/* Right Panel - Preview */}
          <div className="xl:col-span-1">
            <Card className="glass-card border-0 shadow-card h-fit">
              <CardHeader>
                <CardTitle>Preview</CardTitle>
                <CardDescription>
                  Live preview of your chart
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Selected Fields Display */}
                {selectedFields.length > 0 && (
                  <div className="space-y-2">
                    <h4 className="text-sm font-medium">Campos Selecionados:</h4>
                    <div className="flex flex-wrap gap-2">
                      {selectedFields.map((field, index) => (
                        <div 
                          key={`${field.tableName}-${field.columnName}`}
                          className={`px-2 py-1 text-xs rounded-md border ${
                            field.role === 'dimension' 
                              ? 'bg-blue-50 text-blue-700 border-blue-200' 
                              : 'bg-green-50 text-green-700 border-green-200'
                          }`}
                        >
                          {field.role === 'dimension' ? '游늵' : '游늳'} {field.columnName}
                          {field.aggregation && ` (${field.aggregation})`}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                {/* Chart Preview */}
                <ChartRenderer
                  config={{
                    type: chartType,
                    title: chartTitle || 'Chart Preview',
                    description: chartDescription,
                    xAxis: selectedFields.find(f => f.role === 'dimension')?.columnName || availableColumns[0] || '',
                    yAxis: selectedFields.filter(f => f.role === 'metric').map(f => f.columnName) || availableColumns.slice(1) || [],
                    data
                  }}
                 />
                
                <Button 
                  onClick={handleSaveChart}
                  disabled={isSaving}
                  className="w-full"
                >
                  <Save className="w-4 h-4 mr-2" />
                  {isSaving ? (chartId ? 'Updating...' : 'Saving...') : (chartId ? 'Update Chart' : 'Save Chart')}
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </AppLayout>
  );
}